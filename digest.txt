Directory structure:
└── database/
    ├── __init__.py
    ├── executor.py
    ├── manager.py
    ├── service.py
    ├── strategy.py
    └── validator.py

================================================
FILE: __init__.py
================================================
from .manager import DatabaseManager
from .executor import DatabaseExecutor
from .service import DatabaseService

__all__ = ["DatabaseManager", "DatabaseExecutor", "DatabaseService"]



================================================
FILE: executor.py
================================================
import pandas as pd
from sqlalchemy.engine import Engine
from sqlalchemy.exc import SQLAlchemyError
from .manager import DatabaseManager

class DatabaseExecutor:
    """
    Handles the execution of SQL queries against the database.
    """
    def __init__(self, engine: Engine):
        self._engine = engine

    def execute_query(self, sql_query: str) -> pd.DataFrame:
        """
        Executes a read-only SQL query and returns the results as a pandas DataFrame.

        Args:
            sql_query: The SQL SELECT statement to execute.

        Returns:
            A pandas DataFrame containing the query results.

        Raises:
            RuntimeError: If there is a database execution error.
        """
        try:
            with self._engine.connect() as connection:
                df = pd.read_sql_query(sql_query, connection.connection)
            return df
        except SQLAlchemyError as e:
            raise RuntimeError(f"Database execution failed: {e}") from e



================================================
FILE: manager.py
================================================
from __future__ import annotations
from omegaconf import DictConfig
from sqlalchemy import create_engine
from sqlalchemy.engine import Engine

from .strategy import DatabaseConnectionStrategy, PostgresConnectionStrategy, SqliteConnectionStrategy

class DatabaseManager:
    """
    Manages database connections via a strategy and acts as a factory for itself.
    """
    def __init__(self, strategy: DatabaseConnectionStrategy):
        if not isinstance(strategy, DatabaseConnectionStrategy):
            raise TypeError("A valid DatabaseConnectionStrategy object must be provided.")
        self._strategy = strategy
        self._engine = create_engine(self._strategy.get_uri())

    @classmethod
    def from_config(cls, db_config: DictConfig) -> DatabaseManager:
        """
        Factory class method to build a DatabaseManager with the correct strategy
        based on the provided configuration.
        """
        db_type = db_config.get("type")
        if not db_type:
            raise ValueError("Database 'type' must be specified in the configuration.")

        strategy: DatabaseConnectionStrategy
        params = db_config.get("params", {})

        if db_type == "postgres":
            strategy = PostgresConnectionStrategy(**params)
        elif db_type == "sqlite":
            strategy = SqliteConnectionStrategy(**params)
        else:
            raise NotImplementedError(f"Database type '{db_type}' is not supported.")

        return cls(strategy)

    def get_engine(self) -> Engine:
        """Returns the SQLAlchemy engine instance."""
        return self._engine

    def get_uri(self) -> str:
        """Returns the database connection URI."""
        return self._strategy.get_uri()

    def get_schema_info(self) -> str:
        """Returns the database schema information from the strategy."""
        return self._strategy.get_schema_info()



================================================
FILE: service.py
================================================
import pandas as pd
from omegaconf import DictConfig
import sqlparse

from .manager import DatabaseManager
from .validator import SQLValidator
from .executor import DatabaseExecutor

class DatabaseService:
    """
    A high-level service that orchestrates database operations,
    combining connection management, query validation, and execution.
    """
    def __init__(self, db_config: DictConfig):
        """
        Initializes the DatabaseService by setting up the manager, validator, and executor.

        Args:
            db_config: OmegaConf DictConfig containing database connection details.
        """
        self._manager = DatabaseManager.from_config(db_config)
        self._validator = SQLValidator(self._manager.get_uri())
        self._executor = DatabaseExecutor(self._manager.get_engine())

    def execute_validated_query(self, sql_query: str) -> pd.DataFrame:
        """
        Validates an SQL query and, if valid, executes it.

        Args:
            sql_query: The SQL query string to validate and execute.

        Returns:
            A pandas DataFrame containing the query results.

        Raises:
            ValueError: If the query is invalid or not a SELECT statement.
            RuntimeError: If there is a database execution error.
        """
        is_valid, message = self._validator.verify_executable_select_query(sql_query)
        if not is_valid:
            raise ValueError(f"Invalid SQL query: {message}")

        return self._executor.execute_query(sql_query)

    def get_schema_info(self) -> str:
        """
        Retrieves the database schema information from the underlying strategy.

        Returns:
            A string representation of the database schema.
        """
        return self._manager.get_schema_info()



================================================
FILE: strategy.py
================================================
from sqlalchemy import create_engine, inspect

# --- Abstract Strategy ---
class DatabaseConnectionStrategy(ABC):
    """Abstract base class for a database connection strategy."""
    @abstractmethod
    def get_uri(self) -> str:
        """Constructs the SQLAlchemy database URI."""
        pass

    @abstractmethod
    def get_schema_info(self) -> str:
        """Fetches and returns the database schema information as a string."""
        pass

# --- Concrete Strategies ---
@dataclass
class PostgresConnectionStrategy(DatabaseConnectionStrategy):
    """Strategy for connecting to a PostgreSQL database."""
    host: str
    port: int
    user: str
    password: str
    dbname: str

    def get_uri(self) -> str:
        # Assumes psycopg2 driver
        return f"postgresql+psycopg2://{self.user}:{self.password}@{self.host}:{self.port}/{self.dbname}"

    def get_schema_info(self) -> str:
        engine = create_engine(self.get_uri())
        inspector = inspect(engine)
        schema_info = []
        for table_name in inspector.get_table_names():
            schema_info.append(f"TABLE {table_name}:")
            for column in inspector.get_columns(table_name):
                schema_info.append(f"  {column['name']} {column['type']}")
        return "\n".join(schema_info)

@dataclass
class SqliteConnectionStrategy(DatabaseConnectionStrategy):
    """Strategy for connecting to a SQLite database."""
    db_path: str

    def get_uri(self) -> str:
        return f"sqlite:///{self.db_path}"

    def get_schema_info(self) -> str:
        engine = create_engine(self.get_uri())
        inspector = inspect(engine)
        schema_info = []
        for table_name in inspector.get_table_names():
            schema_info.append(f"TABLE {table_name}:")
            for column in inspector.get_columns(table_name):
                schema_info.append(f"  {column['name']} {column['type']}")
        return "\n".join(schema_info)



================================================
FILE: validator.py
================================================
from sqlalchemy import create_engine, text
from sqlalchemy.exc import ProgrammingError
import sqlparse

class SQLValidator:
    """
    Validates SQL queries by attempting to generate an execution plan using EXPLAIN.
    """
    def __init__(self, db_uri: str):
        """
        Initializes the validator with a database connection URI.

        Args:
            db_uri: A SQLAlchemy-compatible database URI
                    (e.g., 'sqlite:///mydatabase.db', 'postgresql://user:pass@host/dbname').
        """
        try:
            self.engine = create_engine(db_uri)
        except ImportError:
            raise ImportError("SQLAlchemy is not installed. Please install it with 'pip install SQLAlchemy'.")

    def verify_executable_select_query(self, sql_query: str) -> tuple[bool, str]:
        """
        Validates the SQL query syntax by asking the database to create an
        execution plan. It only validates SELECT statements.

        Args:
            sql_query: The SQL query string to validate.

        Returns:
            A tuple (is_valid: bool, message: str).
            The message will be 'OK' on success or an error message on failure.
        """
        try:
            statement_type = sqlparse.parse(sql_query)[0].get_type()
            if statement_type != 'SELECT':
                return False, f"Error: Query must be a SELECT statement, but it is a {statement_type} statement."
        except IndexError:
            return False, "Error: The SQL query is empty or invalid."

        query = sql_query.strip()

        try:
            with self.engine.connect() as connection:
                # Using text() is important for safely passing the query.
                # The EXPLAIN statement asks the DB to parse and plan the query.
                connection.execute(text(f"EXPLAIN {query}"))
            return True, "OK"
        except ProgrammingError as e:
            # This exception is commonly raised for syntax errors.
            return False, f"Syntax Error: {e.orig}"
        except Exception as e:
            return False, f"An unexpected error occurred during validation: {e}"


