from __future__ import annotations
from omegaconf import DictConfig
import pandas as pd
from pathlib import Path
from typing import List, TypedDict, Optional, Dict, Any
from langgraph.graph import StateGraph, END

from core.llm import LLMService
from core.database import AgentDatabaseService


class SQLAgentState(TypedDict):
    """
    Represents the state of our SQL Agent.

    Attributes:
        natural_language_question: The initial user question.
        db_context: The database schema and table info.
        history: A log of all attempts and errors.
        max_attempts: The maximum number of retries.
        current_attempt: The current attempt number.
        generated_sql: The SQL query generated by the LLM in the current step.
        final_dataframe: The final, successful result of the query.
        error: The most recent error message, used for conditional routing.
    """
    natural_language_question: str
    db_context: Dict[str, Any]
    history: List[str]
    max_attempts: int
    current_attempt: int
    generated_sql: str
    final_dataframe: Optional[pd.DataFrame]
    error: Optional[str]


class SQLAgent:
    """
    An agent that uses LangGraph to define a robust, stateful workflow for
    generating, executing, and self-correcting SQL queries.
    """

    def __init__(
        self, 
        llm_service: LLMService, 
        db_service: AgentDatabaseService, 
        name: str,
        max_attempts: int,
    ):
        self.llm_service = llm_service
        self.db_service = db_service
        self.name = name
        self.max_attempts = max_attempts

        # Build and compile the LangGraph workflow
        self.workflow = self._build_graph()
        self.app = self.workflow.compile()

    @classmethod
    def from_config(
        cls, 
        agent_config: DictConfig, 
        databases_config: DictConfig, 
        llm_providers_config: DictConfig, 
        prompts_base_path: Path
    ) -> "SQLAgent":
        """
        Creates an SQLAgent from configuration files.
        """
        # Create LLMService
        llm_service = LLMService(
            agent_prompts_dir=agent_config.prompts_dir,
            provider_key=agent_config.llm_provider_key,
            llm_providers_config=llm_providers_config,
            prompts_base_path=prompts_base_path
        )

        # Create AgentDatabaseService
        db_key = agent_config.database_key
        db_config = databases_config.get(db_key)
        if db_config is None:
            raise ValueError(f"Database key '{db_key}' not found in databases configuration.")
        db_service = AgentDatabaseService(db_config)

        return cls(
            llm_service=llm_service,
            db_service=db_service,
            name=agent_config.name,
            max_attempts=agent_config.max_attempts
        )

    def _build_graph(self) -> StateGraph:
        """Builds the LangGraph StateGraph for the agent's workflow."""
        graph = StateGraph(SQLAgentState)

        # --- 2. Define the Nodes of the Graph ---
        graph.add_node("generate_sql", self.generate_sql_node)
        graph.add_node("execute_sql", self.execute_sql_node)

        # --- 3. Define the Edges of the Graph ---
        graph.set_entry_point("generate_sql")
        graph.add_edge("generate_sql", "execute_sql")
        
        # This conditional edge is the core of the retry loop
        graph.add_conditional_edges(
            "execute_sql",
            self.should_retry_node,
            {
                "retry": "generate_sql",  # If retry is needed, go back to generate
                "end": END               # If successful or out of retries, end
            }
        )
        
        return graph

    # --- Node Function Definitions ---

    def generate_sql_node(self, state: SQLAgentState) -> Dict[str, Any]:
        """
        Node that generates an SQL query using the LLM.
        """
        print(f"--- Attempt {state['current_attempt'] + 1} of {state['max_attempts']}: Generating SQL ---")
        
        llm_variables = {
            "database_dialect": state["db_context"]["database_dialect"],
            "schema_definition": state["db_context"]["table_info"],
            "user_question": state["natural_language_question"],
            "history": "\n".join(state["history"])
        }
        
        generated_sql = self.llm_service.generate_text(llm_variables)
        print(f"Generated SQL:\n{generated_sql}")

        history = state["history"] + [f"ATTEMPT {state['current_attempt'] + 1} SQL:\n{generated_sql}"]
        
        return {
            "current_attempt": state["current_attempt"] + 1,
            "generated_sql": generated_sql,
            "history": history
        }

    def execute_sql_node(self, state: SQLAgentState) -> Dict[str, Any]:
        """
        Node that executes the generated SQL query and handles potential errors.
        """
        print("--- Executing SQL ---")
        try:
            results_df = self.db_service.execute_for_dataframe(state["generated_sql"])
            print("Successfully executed SQL.")
            return {"final_dataframe": results_df, "error": None}
        except (ValueError, RuntimeError) as e:
            error_message = f"Error: {e}"
            logger.error(f"Execution failed with error:\n{error_message}")
            history = state["history"] + [f"DATABASE ERROR:\n{error_message}"]
            return {"error": error_message, "history": history, "final_dataframe": None}

    def should_retry_node(self, state: SQLAgentState) -> str:
        """
        Conditional edge logic. Determines whether to retry generation or end.
        """
        if state["error"] is None:
            # Success, no error
            print("--- Workflow successful ---")
            return "end"
        
        if state["current_attempt"] >= state["max_attempts"]:
            # Out of retries
            print("--- Max attempts reached, ending workflow ---")
            return "end"
        
        # Error occurred and we have attempts left
        print("--- Error found, retrying ---")
        return "retry"

    # --- Public Method to Run the Agent ---

    def run(self, natural_language_question: str) -> pd.DataFrame:
        """
        Executes the agent's workflow to answer a natural language question.

        Args:
            natural_language_question: The user's question.

        Returns:
            A pandas DataFrame with the query results.

        Raises:
            RuntimeError: If the agent fails to produce a valid SQL query
                          after all attempts.
        """
        # Prepare the initial state
        initial_state: SQLAgentState = {
            "natural_language_question": natural_language_question,
            "db_context": self.db_service.get_context_for_agent(),
            "history": [],
            "max_attempts": self.max_attempts,
            "current_attempt": 0,
            "generated_sql": "",
            "final_dataframe": None,
            "error": None
        }

        # Invoke the graph
        final_state = self.app.invoke(initial_state)

        # Check the final result
        if final_state["final_dataframe"] is not None:
            return final_state["final_dataframe"]
        else:
            final_error = final_state["error"] or "Unknown error"
            raise RuntimeError(
                f"Agent failed to generate a valid SQL query after {self.max_attempts} attempts. "
                f"Final error: {final_error}"
            )