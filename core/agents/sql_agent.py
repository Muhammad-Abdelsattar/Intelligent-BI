from __future__ import annotations
import logging
from omegaconf import DictConfig
import pandas as pd
from pathlib import Path
from typing import List, TypedDict, Optional, Dict, Any
from langgraph.graph import StateGraph, END

from core.llm import LLMService
from core.database import AgentDatabaseService


class SQLAgentState(TypedDict):
    """
    Represents the state of our SQL Agent.

    Attributes:
        natural_language_question: The initial user question.
        db_context: The database schema and table info.
        history: A log of all attempts and errors.
        max_attempts: The maximum number of retries.
        current_attempt: The current attempt number.
        generated_sql: The SQL query generated by the LLM in the current step.
        final_dataframe: The final, successful result of the query.
        error: The most recent error message, used for conditional routing.
    """
    natural_language_question: str
    db_context: Dict[str, Any]
    history: List[str]
    max_attempts: int
    current_attempt: int
    generated_sql: str
    final_dataframe: Optional[pd.DataFrame]
    error: Optional[str]


logger = logging.getLogger(__name__)


class SQLAgent:
    """
    An agent that uses LangGraph to define a robust, stateful workflow for
    generating, executing, and self-correcting SQL queries.
    """

    def __init__(
        self,
        llm_service: LLMService,
        db_service: AgentDatabaseService,
        name: str,
        max_attempts: int,
    ):
        self.llm_service = llm_service
        self.db_service = db_service
        self.name = name
        self.max_attempts = max_attempts

        # Build and compile the LangGraph workflow
        self.workflow = self._build_graph()
        self.app = self.workflow.compile()

    @classmethod
    def from_config(
        cls,
        agent_key: str,
        app_config: DictConfig,
        prompts_base_path: Path
    ) -> "SQLAgent":
        """
        Creates an SQLAgent from a unified application configuration.

        Args:
            agent_key: The key for this agent in the 'agents.yaml' config.
            app_config: The complete, namespaced application configuration object.
            prompts_base_path: The path to the base prompts directory.
        """
        agent_config = app_config.agents.get(agent_key)
        if not agent_config:
            raise ValueError(f"Agent key '{agent_key}' not found in agents configuration.")

        # Create LLMService, passing the 'llms' section of the config
        llm_service = LLMService(
            agent_prompts_dir=agent_config.prompts_dir,
            provider_key=agent_config.llm_provider_key,
            llm_config=app_config.llms, # Pass the entire llms config section
            prompts_base_path=prompts_base_path
        )

        # Create AgentDatabaseService
        db_key = agent_config.database_key
        db_config = app_config.databases.get(db_key) # Look up the db_config in the 'databases' section
        if db_config is None:
            raise ValueError(f"Database key '{db_key}' not found in databases configuration.")
        db_service = AgentDatabaseService(db_config)

        return cls(
            llm_service=llm_service,
            db_service=db_service,
            name=agent_config.name,
            max_attempts=agent_config.max_attempts
        )

    def _build_graph(self) -> StateGraph:
        """Builds the LangGraph StateGraph for the agent's workflow."""
        graph = StateGraph(SQLAgentState)

        # --- 2. Define the Nodes of the Graph ---
        graph.add_node("generate_sql", self.generate_sql_node)
        graph.add_node("execute_sql", self.execute_sql_node)

        # --- 3. Define the Edges of the Graph ---
        graph.set_entry_point("generate_sql")
        graph.add_edge("generate_sql", "execute_sql")

        # This conditional edge is the core of the retry loop
        graph.add_conditional_edges(
            "execute_sql",
            self.should_retry_node,
            {
                "retry": "generate_sql",  # If retry is needed, go back to generate
                "end": END               # If successful or out of retries, end
            }
        )

        return graph

    # --- Node Function Definitions ---

    def generate_sql_node(self, state: SQLAgentState) -> Dict[str, Any]:
        """
        Node that generates an SQL query using the LLM.
        """
        logger.info(f"--- Attempt {state['current_attempt'] + 1} of {state['max_attempts']}: Generating SQL ---")

        llm_variables = {
            "database_dialect": state["db_context"]["database_dialect"],
            "schema_definition": state["db_context"]["table_info"],
            "user_question": state["natural_language_question"],
            "history": "\n".join(state["history"])
        }

        generated_sql = self.llm_service.generate_text(llm_variables)
        logger.info(f"Generated SQL:\n{generated_sql}")

        history = state["history"] + [f"ATTEMPT {state['current_attempt'] + 1} SQL:\n{generated_sql}"]

        return {
            "current_attempt": state["current_attempt"] + 1,
            "generated_sql": generated_sql,
            "history": history
        }

    def execute_sql_node(self, state: SQLAgentState) -> Dict[str, Any]:
        """
        Node that executes the generated SQL query and handles potential errors.
        """
        generated_sql = state["generated_sql"].strip()

        # First, check if the LLM returned a deliberate error instead of SQL
        if generated_sql.startswith("Error:"):
            logger.warning(f"LLM refused to generate SQL, returning error: {generated_sql}")
            # Set the error to be the exact message from the LLM and stop.
            return {"final_dataframe": None, "error": generated_sql}

        logger.info("--- Executing SQL ---")
        try:
            results_df = self.db_service.execute_for_dataframe(generated_sql)
            logger.info("Successfully executed SQL.")
            return {"final_dataframe": results_df, "error": None}
        except (ValueError, RuntimeError) as e:
            # This is a database execution error
            error_message = f"Error executing SQL: {e}"
            logger.error(f"Execution failed with error:\n{error_message}")
            history = state["history"] + [f"DATABASE ERROR:\n{error_message}"]
            return {"error": error_message, "history": history, "final_dataframe": None}

    def should_retry_node(self, state: SQLAgentState) -> str:
        """
        Conditional edge logic. Determines whether to retry generation or end.
        """
        error = state.get("error")

        if error is None:
            # Success, no error
            logger.info("--- Workflow successful ---")
            return "end"

        # If the error is the exact same as the generated_sql, it means the LLM
        # deliberately returned an error message. We should not retry.
        if error.strip() == state.get("generated_sql").strip():
            logger.error(f"Workflow ended because LLM returned a deliberate error: {error}")
            return "end"

        # If we are out of retries for a database-side error, end.
        if state["current_attempt"] >= state["max_attempts"]:
            logger.warning("-- Max attempts reached, ending workflow --")
            return "end"

        # A retry-able error (e.g., from the database) occurred and we have attempts left.
        logger.info(f"--- Database error found, retrying ---")
        return "retry"

    # --- Public Method to Run the Agent ---

    def run(self, natural_language_question: str) -> pd.DataFrame:
        """
        Executes the agent's workflow to answer a natural language question.

        Args:
            natural_language_question: The user's question.

        Returns:
            A pandas DataFrame with the query results.

        Raises:
            RuntimeError: If the agent fails to produce a valid SQL query
                          after all attempts.
        """
        # Prepare the initial state
        initial_state: SQLAgentState = {
            "natural_language_question": natural_language_question,
            "db_context": self.db_service.get_context_for_agent(),
            "history": [],
            "max_attempts": self.max_attempts,
            "current_attempt": 0,
            "generated_sql": "",
            "final_dataframe": None,
            "error": None
        }

        # Invoke the graph
        final_state = self.app.invoke(initial_state)

        # Check the final result
        if final_state["final_dataframe"] is not None:
            return final_state["final_dataframe"]
        else:
            final_error = final_state["error"] or "Unknown error"
            raise RuntimeError(
                # f"Agent failed to generate a valid SQL query after {self.max_attempts} attempts. "
                f"Agent failed to generate a valid SQL query after maximum number of attempts. "
                f"Final error: {final_error}"
            )